/* The contents of this file are subject to the license and copyright terms
 * detailed in the license directory at the root of the source tree (also
 * available online at http://fedora-commons.org/license/).
 */
package dk.dbc.opensearch.fedora.search;

import org.fcrepo.server.management.*;
import java.io.IOException;

import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.fcrepo.common.MalformedPIDException;
import org.fcrepo.common.PID;
import org.fcrepo.server.Module;
import org.fcrepo.server.Server;
import org.fcrepo.server.errors.ModuleInitializationException;
import org.fcrepo.server.errors.ServerException;
import org.fcrepo.server.search.FieldSearch;


/**
 * A PIDGenerator that uses a database to keep track of the highest pid it knows
 * about for each namespace.
 *
 * @author Chris Wilper
 */
public class LucenePIDGenerator
    extends Module
        implements PIDGenerator {

    private static final Logger logger =
            LoggerFactory.getLogger(DBPIDGenerator.class);

    private final HashMap m_highestID;

    private PID m_lastPID;

    protected FieldSearch m_fieldSearch;

    /**
     * Initialize the DBPIDGenerator. This initializes the memory hash with
     * values in the database, if any. If oldPidGenDir is not null, the
     * constructor will then call neverGeneratePID on the most recently
     * generated PID as reported by the log files in that directory. This is to
     * support automatic upgrade of this functionality from versions of Fedora
     * prior to 1.2.
     */
    public LucenePIDGenerator(Map moduleParameters, Server server, String role)
            throws ModuleInitializationException {
        super(moduleParameters, server, role);
        m_highestID = new HashMap();
    }

    @Override
    public void postInitModule() throws ModuleInitializationException {
        m_fieldSearch =
                (FieldSearch) getServer()
                        .getModule("org.fcrepo.server.search.FieldSearch");
    }

    /**
     * Generate a new pid that is guaranteed to be unique, within the given
     * namespace.
     */
    public synchronized PID generatePID(String namespace) throws IOException {
        int i = getHighestID(namespace);
        i++;

        try {
            m_lastPID = new PID(namespace + ":" + i);
        } catch (MalformedPIDException e) {
            throw new IOException(e);
        }

        setHighestID(namespace, i);

        return m_lastPID;
    }

    /**
     * Get the last pid that was generated.
     */
    public synchronized PID getLastPID() {
        return m_lastPID;
    }

    /**
     * Cause the given PID to never be generated by the PID generator.
     */
    public synchronized void neverGeneratePID(String pid) throws IOException {
        logger.debug("Never generating PID: " + pid);
        try {
            PID p = new PID(pid);
            String ns = p.getNamespaceId();
            int id = Integer.parseInt(p.getObjectId());
            if (id > getHighestID(ns)) {
                setHighestID(ns, id);
            }
        } catch (MalformedPIDException mpe) {
            throw new IOException(mpe);
        } catch (NumberFormatException nfe) {
            // if the id part is not numeric, we already know we'll
            // never generate that id because all generated ids are numeric.
        }
    }

    /**
     * Gets the highest id ever used for the given namespace.
     */
    private int getHighestID(String namespace) {
        Integer i = (Integer) m_highestID.get(namespace);
        if (i == null) {
            return findHighestPid(namespace);
        }
        return i.intValue();
    }

    private int findHighestPid(String namespace) {
        try {
            return m_fieldSearch.findHighestID(namespace);
        }
        catch (ServerException ex) {
            logger.error("Unable to determine ighest pid for namespace " + namespace, ex);
            return 0;
        }
    }


    /**
     * Sets the highest id ever used for the given namespace.
     */
    private void setHighestID(String namespace, int id) throws IOException {
        logger.debug("Setting highest ID for " + namespace + " to " + id);
        m_highestID.put(namespace, new Integer(id));
    }

}
